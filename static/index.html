<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stream TTS - Modern</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom base styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* Lighter gray background */
        }

        /* Custom styles for a cleaner look */
        .container {
            background-color: #ffffff;
            padding: 2rem 2.5rem; /* Increased padding */
            border-radius: 1rem; /* Larger border radius */
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.05), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Softer shadow */
            max-width: 800px;
            width: 100%;
            margin: 2rem auto; /* Center container with margin */
        }

        textarea, select {
            border-radius: 0.5rem; /* Consistent rounded corners */
            border-color: #d1d5db; /* Tailwind gray-300 */
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        textarea:focus, select:focus {
            border-color: #3b82f6; /* Tailwind blue-500 */
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25); /* Focus ring */
            outline: none;
        }

        /* Custom button styles */
        .action-button {
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            display: inline-flex; /* Align icon and text */
            align-items: center;
            justify-content: center;
            gap: 0.5rem; /* Space between icon and text */
            font-weight: 500;
        }
        .action-button:hover {
            opacity: 0.9;
        }
        .action-button:active {
            transform: scale(0.98);
        }

        /* Message box styles */
        .message {
            margin-top: 1rem;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            border-width: 1px;
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .message.info {
            background-color: #eff6ff; /* Tailwind blue-50 */
            color: #1e40af; /* Tailwind blue-800 */
            border-color: #bfdbfe; /* Tailwind blue-200 */
        }
        .message.success {
            background-color: #f0fdf4; /* Tailwind green-50 */
            color: #15803d; /* Tailwind green-700 */
            border-color: #bbf7d0; /* Tailwind green-200 */
        }
        .message.warning {
             background-color: #fffbeb; /* Tailwind yellow-50 */
             color: #b45309; /* Tailwind yellow-700 */
             border-color: #fde68a; /* Tailwind yellow-200 */
        }
        .message.error {
            background-color: #fef2f2; /* Tailwind red-50 */
            color: #b91c1c; /* Tailwind red-700 */
            border-color: #fecaca; /* Tailwind red-200 */
        }
        .message i { /* Style for icons in messages */
             width: 1.1rem;
             height: 1.1rem;
        }

        /* Audio player and controls styling */
        #audio-container {
            margin-top: 1.5rem;
            padding: 1.5rem;
            background-color: #f9fafb; /* Slightly off-white background */
            border-radius: 0.75rem;
            border: 1px solid #e5e7eb; /* Subtle border */
        }
        /* Hide the default audio player visually, but keep it functional */
        #single-audio-player {
            display: block; /* Keep it in layout for JS */
            height: 0;      /* Hide visually */
            width: 0;       /* Hide visually */
            margin: 0;      /* Remove margins */
            padding: 0;     /* Remove padding */
            border: none;   /* Remove border */
            opacity: 0;     /* Make transparent */
            position: absolute; /* Take out of flow if needed, though height/width 0 might suffice */
            z-index: -1;      /* Put behind other elements */
        }
        #custom-controls {
            display: flex;
            align-items: center;
            justify-content: space-between; /* Space out controls */
            gap: 1rem; /* Gap between control groups */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            margin-top: 0; /* Adjust margin since default player is hidden */
        }
         #custom-controls .control-group {
            display: flex;
            align-items: center;
            gap: 0.75rem; /* Gap within control groups */
        }
        #custom-controls button {
            background-color: #e5e7eb; /* Light gray */
            color: #374151; /* Darker gray text */
            padding: 0.5rem;
            border-radius: 9999px; /* Fully rounded */
            border: none;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
        }
        #custom-controls button:hover:not(:disabled) { /* Add :not(:disabled) */
            background-color: #d1d5db; /* Slightly darker gray */
        }
        #custom-controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #custom-controls button i {
            width: 1.25rem; /* 20px */
            height: 1.25rem;
            display: block; /* Ensure icon size is respected */
        }
        #volume-control {
            width: 100px; /* Adjust width as needed */
            cursor: pointer;
        }
        #speed-control {
            padding: 0.4rem 0.6rem;
            border-radius: 0.375rem; /* md */
            border: 1px solid #d1d5db;
            background-color: white;
            font-size: 0.875rem;
            cursor: pointer;
        }
        #speed-control:focus {
            border-color: #3b82f6;
             box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
             outline: none;
        }

        /* Current paragraph display */
        #current-paragraph {
            margin-top: 1.5rem;
            padding: 1rem 1.25rem;
            background-color: #eef2ff; /* Indigo-50 */
            border-radius: 0.5rem;
            color: #4338ca; /* Indigo-700 */
            font-style: italic;
            font-size: 0.95rem;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
            text-align: left; /* Align left for readability */
            border: 1px solid #c7d2fe; /* Indigo-200 */
        }

        /* Hide elements */
        .hidden {
            display: none !important; /* Use !important to override potential conflicts */
        }

        /* Ensure Lucide icons are sized correctly */
        [data-lucide] {
            width: 1.25em;
            height: 1.25em;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div class="container space-y-6">
        <h1 class="text-3xl font-bold text-center text-gray-900">Text-to-Speech Stream</h1>

        <div id="message-box" class="message info hidden"></div>

        <div>
            <label for="text" class="block text-sm font-medium text-gray-700 mb-1">Enter Text or Load from File:</label>
            <textarea id="text" class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 shadow-sm" rows="6" placeholder="Enter text here, paragraphs separated by double line breaks..."></textarea>
            <div class="mt-4 flex items-center space-x-2">
                <input type="file" id="file-input" accept=".txt,.md,.html,.pdf" class="hidden">
                <button id="load-file-button" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-400 action-button">
                    <i data-lucide="folder-open" class="w-5 h-5"></i>
                    <span>Browse for File</span>
                </button>
                <span id="file-name" class="text-sm text-gray-600 truncate">No file selected</span>
            </div>
        </div>

        <div>
            <label for="voice-select" class="block text-sm font-medium text-gray-700 mb-1">Select Voice:</label>
            <select id="voice-select" class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 shadow-sm bg-white">
                <option value="">Loading voices...</option>
            </select>
        </div>

        <div>
            <label for="target-language-select" class="block text-sm font-medium text-gray-700 mb-1">Translate To (Optional):</label>
            <select id="target-language-select" class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 shadow-sm bg-white">
                <option value="">-- Do Not Translate --</option>
                <!-- Languages will be loaded here by JavaScript -->
            </select>
        </div>

        <button id="stream-button" class="w-full bg-blue-600 text-white py-3 px-4 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 action-button disabled:opacity-50 disabled:cursor-not-allowed" disabled>
            <span id="stream-button-icon"><i data-lucide="play-circle" class="w-5 h-5"></i></span>
            <span id="stream-button-text">Stream Audio</span>
        </button>

        <div id="audio-container" class="hidden">
            <audio id="single-audio-player"></audio> <div id="custom-controls">
                <div class="control-group">
                    <button id="restart-button" title="Restart Track" disabled><i data-lucide="rewind"></i></button>
                    <button id="play-pause-button" title="Play/Pause" disabled><i data-lucide="play"></i></button>
                    <button id="stop-button" title="Stop" disabled><i data-lucide="stop-circle"></i></button>
                    <button id="next-button" title="Next Track" disabled><i data-lucide="skip-forward"></i></button>
                </div>

                <div class="control-group">
                    <i data-lucide="volume-2" class="text-gray-600"></i>
                    <input type="range" id="volume-control" min="0" max="1" step="0.05" value="1" class="volume-slider" disabled>
                </div>

                <div class="control-group">
                     <i data-lucide="gauge-circle" class="text-gray-600"></i>
                    <select id="speed-control" disabled>
                        <option value="0.5">0.5x</option>
                        <option value="0.75">0.75x</option>
                        <option value="1" selected>1x</option>
                        <option value="1.25">1.25x</option>
                        <option value="1.5">1.5x</option>
                        <option value="2">2x</option>
                    </select>
                </div>
            </div>

             <div id="current-paragraph" class="hidden"></div>
        </div>
    </div>

    <script>
        // --- DOM Element References ---
        const textInput = document.getElementById('text');
        const voiceSelect = document.getElementById('voice-select');
        const targetLanguageSelect = document.getElementById('target-language-select');
        const streamButton = document.getElementById('stream-button');
        const audioContainer = document.getElementById('audio-container');
        const messageBox = document.getElementById('message-box');
        const singleAudioPlayer = document.getElementById('single-audio-player'); // Still needed for JS
        const currentParagraphDiv = document.getElementById('current-paragraph');
        const customControlsDiv = document.getElementById('custom-controls');
        const playPauseButton = document.getElementById('play-pause-button');
        const stopButton = document.getElementById('stop-button');
        const volumeControl = document.getElementById('volume-control');
        const speedControl = document.getElementById('speed-control');
        const restartButton = document.getElementById('restart-button');
        const nextButton = document.getElementById('next-button');
        const fileInput = document.getElementById('file-input');
        const loadFileButton = document.getElementById('load-file-button');
        const fileNameSpan = document.getElementById('file-name');

        // --- State Variables ---
        const clientId = Math.floor(Math.random() * 1000000);
        let ws;
        let audioQueue = [];
        let isPlaying = false;
        let isStreamProcessing = false;
        let isAudioSetup = false;
        let isStopping = false;

        // --- Constants ---
        const WS_RECONNECT_DELAY = 5000;

        // --- Utility Functions ---
        function showMessage(type, message) {
            messageBox.className = `message ${type}`;
            let iconName = 'info';
            if (type === 'success') iconName = 'check-circle';
            if (type === 'warning') iconName = 'alert-triangle';
            if (type === 'error') iconName = 'alert-circle';
            messageBox.innerHTML = `<i data-lucide="${iconName}"></i><span>${message}</span>`;
            lucide.createIcons({ nodes: [messageBox.querySelector('i')] });
            messageBox.classList.remove('hidden');
        }

        function hideMessage() {
            messageBox.classList.add('hidden');
            messageBox.textContent = '';
        }

        function displayParagraph(text) {
            console.log("Displaying paragraph:", text);
            currentParagraphDiv.textContent = text || " ";
            currentParagraphDiv.classList.remove('hidden');
        }

        function hideParagraph() {
            console.log("Hiding paragraph display");
            currentParagraphDiv.classList.add('hidden');
            currentParagraphDiv.textContent = '';
        }

        function updatePlayPauseIcon(showPlay = true) {
            const iconName = showPlay ? 'play' : 'pause';
            playPauseButton.innerHTML = `<i data-lucide="${iconName}"></i>`;
            lucide.createIcons({ nodes: [playPauseButton.querySelector('i')] });
        }

        function setControlsDisabled(disabled) {
            playPauseButton.disabled = disabled;
            stopButton.disabled = disabled;
            restartButton.disabled = disabled;
            volumeControl.disabled = disabled;
            speedControl.disabled = disabled;
            if (disabled) {
                 updatePlayPauseIcon(true);
            }
             updateNextButtonState(); // Still manage next button based on queue
        }

        function updateNextButtonState() {
            nextButton.disabled = audioQueue.length === 0;
        }


        // --- Core Logic ---
        async function fetchVoices() {
            voiceSelect.disabled = true;
            try {
                const response = await fetch('/api/voices');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const voices = await response.json();
                if (voices.error) throw new Error(voices.error);

                voiceSelect.innerHTML = '<option value="">-- Select a Voice (Optional) --</option>';
                if (voices && voices.length > 0) {
                    voices.forEach(voice => {
                        const option = document.createElement('option');
                        option.value = voice.Name;
                        option.textContent = `${voice.ShortName} (${voice.Gender}, ${voice.Locale})`;
                        voiceSelect.appendChild(option);
                    });
                    voiceSelect.disabled = false;
                } else {
                    voiceSelect.innerHTML = '<option value="">No voices found</option>';
                    showMessage('warning', 'Could not fetch voices. Using default server voice.');
                }
            } catch (error) {
                console.error("Error fetching voices:", error);
                voiceSelect.innerHTML = '<option value="">Error loading voices</option>';
                showMessage('error', `Failed to load voices: ${error.message}. Using default server voice.`);
                 voiceSelect.disabled = true;
            }
        }

        async function fetchTranslationLanguages() {
            targetLanguageSelect.disabled = true;
            try {
                const response = await fetch('/api/translation_languages');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const languages = await response.json();
                if (languages.error) throw new Error(languages.error);

                targetLanguageSelect.innerHTML = '<option value="">-- Do Not Translate --</option>';
                if (languages && languages.length > 0) {
                    languages.forEach(lang => {
                        const option = document.createElement('option');
                        option.value = lang.code;
                        option.textContent = lang.name;
                        targetLanguageSelect.appendChild(option);
                    });
                    targetLanguageSelect.disabled = false;
                } else {
                    targetLanguageSelect.innerHTML = '<option value="">No translation languages found</option>';
                    showMessage('warning', 'Could not fetch translation languages.');
                }
            } catch (error) {
                console.error("Error fetching translation languages:", error);
                targetLanguageSelect.innerHTML = '<option value="">Error loading languages</option>';
                showMessage('error', `Failed to load translation languages: ${error.message}.`);
                targetLanguageSelect.disabled = true;
            }
        }

        function connectWebSocket() {
            if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;

            const wsProtocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
            const wsUrl = `${wsProtocol}${window.location.host}/ws/${clientId}`;
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log(`WebSocket connected for client ${clientId}`);
                showMessage('success', 'Connected to server.');
            streamButton.disabled = false;
            setStreamButtonLoading(false); // Ensure button is reset on connect
            hideMessage();
        };

        ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    console.log("Received WS message:", data);

                    if (data.type === 'audio_url' && data.url && data.text !== undefined) {
                        console.log("Received audio chunk:", data.url, "| Text:", data.text);
                        audioQueue.push({ url: data.url, text: data.text });
                        updateNextButtonState();
                        console.log("Audio queue length:", audioQueue.length);
                        if (!isPlaying) {
                            console.log("Triggering playNextAudio from ws.onmessage");
                            playNextAudio();
                        }
                    } else if (data.type === 'complete') {
                        console.log("Server processing complete message received.");
                        isStreamProcessing = false;
                         if (data.warning) showMessage('warning', data.warning);
                         if (!isPlaying && audioQueue.length === 0) {
                             showMessage('success', 'Processing complete. Playback finished or no audio generated.');
                             resetAudioPlayerUI();
                         } else if (isPlaying || audioQueue.length > 0) {
                             showMessage('info', 'All audio chunks received. Playback in progress...');
                         }
                         setStreamButtonLoading(false); // Re-enable button on completion
                     } else if (data.type === 'error') {
                         console.error("Server error message received:", data.message);
                         showMessage('error', `Server error: ${data.message}`);
                         isStreamProcessing = false;
                         setStreamButtonLoading(false); // Re-enable button on error
                         resetAudioPlayerUI();
                     } else if (data.type === 'stopped') {
                         console.log("Server stopped message received:", data.message);
                         showMessage('info', data.message || 'TTS generation stopped');
                         isStreamProcessing = false;
                         setStreamButtonLoading(false); // Re-enable button
                         // Don't reset audio player UI here - let user continue with existing audio
                     } else if (data.message) {
                         console.log("Server message:", data.message);
                    }
                } catch (e) {
                    console.error("Error parsing WebSocket message:", e, "Data:", event.data);
                     showMessage('error', 'Received invalid message from server.');
                }
            };

            ws.onerror = (error) => {
                console.error("WebSocket error:", error);
                showMessage('error', 'WebSocket connection error. Check server and network.');
                 streamButton.disabled = true; // Keep disabled during error
                 setStreamButtonLoading(false); // Reset icon on error
                 isStreamProcessing = false;
                 resetAudioPlayerUI();
                 setTimeout(connectWebSocket, WS_RECONNECT_DELAY);
             };

             ws.onclose = (event) => {
                 console.log(`WebSocket closed for client ${clientId}:`, event.code, event.reason);
                 streamButton.disabled = true; // Disable on close
                 setStreamButtonLoading(false); // Reset icon on close
                 isStreamProcessing = false;
                 resetAudioPlayerUI();
                 if (!event.wasClean) {
                     showMessage('warning', 'Disconnected from server. Attempting to reconnect...');
                     setTimeout(connectWebSocket, WS_RECONNECT_DELAY);
                } else {
                     showMessage('info', 'Disconnected from server.');
                }
            };
        }

        function playNextAudio() {
            console.log("Attempting playNextAudio. Queue length:", audioQueue.length, "isPlaying:", isPlaying, "isStreamProcessing:", isStreamProcessing);

            if (isPlaying) {
                console.log("Already playing, returning.");
                return;
            }

            updateNextButtonState();

            if (audioQueue.length > 0) {
                isPlaying = true;
                const audioChunk = audioQueue.shift();
                console.log("Playing next chunk:", audioChunk.url, "| Text:", audioChunk.text);
                updateNextButtonState();

                if (!isAudioSetup) {
                    audioContainer.classList.remove('hidden');
                    setControlsDisabled(false);
                    isAudioSetup = true;
                } else {
                    playPauseButton.disabled = false;
                    stopButton.disabled = false;
                    restartButton.disabled = false;
                    volumeControl.disabled = false;
                    speedControl.disabled = false;
                }

                singleAudioPlayer.src = audioChunk.url;
                singleAudioPlayer.playbackRate = parseFloat(speedControl.value);
                singleAudioPlayer.volume = parseFloat(volumeControl.value);
                singleAudioPlayer.load();
                displayParagraph(audioChunk.text);

                singleAudioPlayer.play().then(() => {
                    console.log("Audio playback started:", audioChunk.url);
                    updatePlayPauseIcon(false);
                    restartButton.disabled = false;
                }).catch(e => {
                    console.error("Audio play failed:", e);
                    showMessage('error', `Audio playback failed: ${e.message}. Try interacting with the page first.`);
                    isPlaying = false;
                    updatePlayPauseIcon(true);
                    restartButton.disabled = true;
                    hideParagraph();
                });

            } else { // audioQueue is empty
                 console.log("Audio queue is empty.");
                 if (!isStreamProcessing) {
                     console.log("Queue empty and processing complete. Playback finished.");
                     isPlaying = false;
                     if (isAudioSetup) showMessage('success', 'Playback complete.');
                     else showMessage('success', 'Processing complete. No audio was generated or played.');
                     resetAudioPlayerUI(false);
                     updatePlayPauseIcon(true);
                     hideParagraph();
                 } else {
                     console.log("Queue empty, waiting for more chunks or completion message.");
                     isPlaying = false;
                     updatePlayPauseIcon(true);
                     restartButton.disabled = true;
                 }
                 updateNextButtonState();
            }
        }

        function resetAudioPlayerUI(hideContainer = true) {
             console.log("Resetting Audio Player UI. Hide container:", hideContainer);
             singleAudioPlayer.pause();
             singleAudioPlayer.removeAttribute('src');
             singleAudioPlayer.load();
             isPlaying = false;
             isAudioSetup = false;
             isStopping = false;
             audioQueue = [];
             hideParagraph();
             setControlsDisabled(true);
             updateNextButtonState();
             updatePlayPauseIcon(true);
             if (hideContainer) {
                 audioContainer.classList.add('hidden');
             }
        }


        // --- Event Listeners ---
        streamButton.addEventListener('click', async () => {
            const text = textInput.value.trim();
            if (!text) {
                showMessage('warning', 'Please enter text to stream.');
                return;
            }
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                showMessage('error', 'WebSocket connection not open. Please wait or refresh.');
                if (!ws || ws.readyState === WebSocket.CLOSED) connectWebSocket();
                return;
            }

            console.log("--- Initiating new stream ---");
            audioQueue = [];
            isStreamProcessing = true;
             resetAudioPlayerUI();
             hideMessage();
             setStreamButtonLoading(true); // Set loading state
             showMessage('info', 'Initiating stream request...');
             
             // Enable stop button during streaming
             stopButton.disabled = false;

             const selectedVoice = voiceSelect.value || null;
             const targetLanguage = targetLanguageSelect.value || null;

            try {
                const response = await fetch('/api/tts/stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text, voice: selectedVoice, target_language: targetLanguage, client_id: clientId })
                });
                const result = await response.json();
                console.log("POST /api/tts/stream response:", result);
                if (!response.ok) throw new Error(result.detail || result.error || `HTTP error ${response.status}`);
                 showMessage('info', 'Stream initiated. Waiting for audio data...');
                 // Button remains loading until WS message indicates completion/error
             } catch (error) {
                 console.error("Error initiating stream POST request:", error);
                 showMessage('error', `Failed to start stream: ${error.message}`);
                 isStreamProcessing = false;
                 setStreamButtonLoading(false); // Reset button on fetch error
                 resetAudioPlayerUI();
             }
         });

        singleAudioPlayer.onended = () => {
            console.log("Audio chunk ended.");
            isPlaying = false;
            restartButton.disabled = true;
            updatePlayPauseIcon(true);
            playNextAudio();
        };

        singleAudioPlayer.onerror = (e) => {
            console.error("Error during audio playback:", e);
            showMessage('error', `Error playing audio chunk: ${singleAudioPlayer.error?.message || 'Unknown error'}`);
            isPlaying = false;
            updatePlayPauseIcon(true);
            restartButton.disabled = true;
            hideParagraph();
            playNextAudio();
        };

         // --- Custom Controls Event Listeners ---
         restartButton.addEventListener('click', () => {
             if (!singleAudioPlayer.src || !isAudioSetup) return;
             console.log("Restart button clicked");
             singleAudioPlayer.currentTime = 0;
             if (singleAudioPlayer.paused) {
                 singleAudioPlayer.play().then(() => updatePlayPauseIcon(false)).catch(e => console.error("Play failed:", e));
             }
         });

         playPauseButton.addEventListener('click', () => {
             if (!singleAudioPlayer.src || !isAudioSetup) return;
             if (singleAudioPlayer.paused) {
                 singleAudioPlayer.play().then(() => updatePlayPauseIcon(false)).catch(e => console.error("Play failed:", e));
             } else {
                 singleAudioPlayer.pause();
                 updatePlayPauseIcon(true);
             }
         });

         stopButton.addEventListener('click', async () => {
             console.log("Stop button clicked");
             
             if (isStopping) {
                 console.log("Stop already in progress");
                 return;
             }
             
             isStopping = true;
             
             // Stop current audio playback immediately
             singleAudioPlayer.pause();
             singleAudioPlayer.currentTime = 0;
             isPlaying = false;
             updatePlayPauseIcon(true);
             
             // Clear the audio queue to prevent further playback
             audioQueue = [];
             updateNextButtonState();
             hideParagraph();
             
             // If streaming is in progress, send stop request to server
             if (isStreamProcessing) {
                 try {
                     showMessage('info', 'Stopping TTS generation...');
                     
                     const response = await fetch(`/api/tts/stop/${clientId}`, {
                         method: 'POST',
                         headers: {
                             'Content-Type': 'application/json'
                         }
                     });
                     
                     const result = await response.json();
                     console.log("Stop TTS response:", result);
                     
                     if (response.ok) {
                         showMessage('success', 'TTS generation stopped successfully');
                         isStreamProcessing = false;
                         setStreamButtonLoading(false);
                     } else {
                         console.warn("Stop request returned non-OK status:", result);
                         showMessage('warning', result.message || 'Stop request completed with warnings');
                     }
                 } catch (error) {
                     console.error("Error stopping TTS:", error);
                     showMessage('warning', 'TTS generation may still be running on server');
                 }
             } else {
                 showMessage('info', 'Playback stopped');
             }
             
             // Reset UI state
             restartButton.disabled = true;
             stopButton.disabled = true;
             isStopping = false;
         });

         nextButton.addEventListener('click', () => {
             if (audioQueue.length > 0) {
                 console.log("Next button clicked");
                 singleAudioPlayer.pause();
                 isPlaying = false;
                 updatePlayPauseIcon(true);
                 restartButton.disabled = true;
                 playNextAudio();
             } else {
                 console.log("Next button clicked, but queue is empty.");
             }
         });

         volumeControl.addEventListener('input', () => {
             singleAudioPlayer.volume = parseFloat(volumeControl.value);
         });

         speedControl.addEventListener('change', () => {
             if (singleAudioPlayer.src && isAudioSetup) {
                singleAudioPlayer.playbackRate = parseFloat(speedControl.value);
             }
         });

         // --- File Input Logic ---
         loadFileButton.addEventListener('click', () => {
             fileInput.click(); // Trigger the hidden file input click
         });

         fileInput.addEventListener('change', async (event) => {
             const file = event.target.files[0];
             if (!file) {
                 fileNameSpan.textContent = 'No file selected';
                 textInput.value = '';
                 return;
             }

             fileNameSpan.textContent = file.name;
             hideMessage();
             showMessage('info', `Loading file: ${file.name}...`);

             try {
                 if (file.type === 'application/pdf') {
                     // Handle PDF conversion on the server
                     const formData = new FormData();
                     formData.append('file', file);

                     const response = await fetch('/api/convert_pdf_to_text', {
                         method: 'POST',
                         body: formData,
                     });

                     if (!response.ok) {
                         const errorData = await response.json();
                         throw new Error(errorData.detail || 'Failed to convert PDF.');
                     }

                     const data = await response.json();
                     textInput.value = data.text;
                     showMessage('success', `Successfully converted and loaded PDF: ${file.name}`);

                 } else if (file.type.startsWith('text/') || file.type === 'application/json' || file.name.endsWith('.md')) {
                     // Handle text-based files
                     const reader = new FileReader();
                     reader.onload = (e) => {
                         textInput.value = e.target.result;
                         showMessage('success', `Successfully loaded file: ${file.name}`);
                     };
                     reader.onerror = () => {
                         showMessage('error', `Failed to read file: ${file.name}`);
                     };
                     reader.readAsText(file);
                 } else {
                     showMessage('warning', 'Unsupported file type. Please select a text, markdown, HTML, or PDF file.');
                     textInput.value = '';
                 }
             } catch (error) {
                 console.error('Error loading file:', error);
                 showMessage('error', `Error loading file: ${error.message}`);
                 textInput.value = '';
             }
         });

         // --- Helper for Button Loading State ---
         const streamButtonIcon = document.getElementById('stream-button-icon');
         const streamButtonText = document.getElementById('stream-button-text');

         function setStreamButtonLoading(isLoading) {
             streamButton.disabled = isLoading;
             if (isLoading) {
                 streamButtonIcon.innerHTML = `<svg class="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                     <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                     <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                 </svg>`;
                 streamButtonText.textContent = 'Processing...';
             } else {
                 streamButtonIcon.innerHTML = `<i data-lucide="play-circle" class="w-5 h-5"></i>`;
                 lucide.createIcons({ nodes: [streamButtonIcon.querySelector('i')] });
                 streamButtonText.textContent = 'Stream Audio';
             }
         }


         // --- Initialization ---
         function initializeApp() {
             console.log("Initializing App...");
             fetchVoices();
             fetchTranslationLanguages();
             connectWebSocket();
             lucide.createIcons(); // Initial icon creation
             resetAudioPlayerUI();
         }

        document.addEventListener('DOMContentLoaded', initializeApp);

    </script>
</body>
</html>
